# CSFT
"Castle-secured" File Transfer application.

## Architecture

The application consists of two major modules:
- a http(s) server waiting for, storing and serving files upon request,
- a client module with encrypt-and-upload and download-and-decrypt a file features.

## Running application

### Requirements

* Java 15+ installed and available on search path
* SBT 1.5.0 or higher installed and available on search path
* Git client installed and available on search path
* Cloned repository for this project:

```bash
git clone https://github.com/eltherion/csft.git
```

### Starting tests

To run tests navigate to cloned repository folder and execute execute:

```bash
cd /path/to/cloned/repository
sbt ";clean;coverage;test;it:test"
```

### Code test coverage

After running tests code coverage reports can be generated by executing command:

```bash
sbt ";coverageReport;coverageAggregate"
```

Reports can be conveniently viewed in any browser by navigating to URL `file:///path/to/cloned/repository/target/scala-2.13/scoverage-report/index.html`

Minimum coverage is set to 80%. Current coverage is over 91%. 

![code_coverage](images/code_coverage.png?raw=true "Code coverage")

### Starting application

Navigate to cloned repository folder:

```bash
cd /path/to/cloned/repository
```

#### Starting server

Run `sbt` with `server` command:

```bash
sbt server
```

By default, this will start a HTTP server listening on port 8081.

#### Using client

To encrypt and upload a file, in a new terminal (opened within the project root directory), run:

```bash
sbt "upload /path/to/file password"
```

Example (using an image in project's resources):
```bash
sbt "upload /path/to/project/encryption/src/main/resources/bouncy_castle.gif T0p&S3cr3t"
```

An output should be similar to this and result with a UUID to a file which is needed to provide upon download: 

```bash
sbt "upload /Users/mmurawski/Projects/csft/encryption/src/main/resources/bouncy_castle.gif T0p&S3cr3t"
[info] running pl.datart.csft.client.Upload /Users/mmurawski/Projects/csft/encryption/src/main/resources/bouncy_castle.gif T0p&S3cr3t
[2021-06-20 19:29:50,295] [INFO ] [io-compute-7] [pl.datart.csft.client.Upload$] [] Encrypting and uploading your file...
[2021-06-20 19:29:50,706] [INFO ] [io-compute-5] [pl.datart.csft.client.Upload$] [] Upload succeeded. Your file fetch ID is: b4fdf3f2-a463-4bd5-a2e4-849ac32789d8.
[2021-06-20 19:29:50,708] [INFO ] [io-compute-5] [org.http4s.blaze.client.PoolManager] [] Shutting down connection pool: curAllocated=1 idleQueues.size=1 waitQueue.size=0 maxWaitQueueLimit=256 closed=false
[success] Total time: 2 s, completed Jun 20, 2021, 7:29:50 PM
```

Here the UUID is `b4fdf3f2-a463-4bd5-a2e4-849ac32789d8`.

To download and decrypt a file run:

```bash
sbt "download uuid password /output/path/with/existing/parent/directory/output.file" 
```

Example:

```bash
sbt "download b4fdf3f2-a463-4bd5-a2e4-849ac32789d8 T0p&S3cr3t /tmp/bouncy_castle_decrypted.gif"
```

An output should be similar to this and result with a decrypted file in a specified location:

```bash
sbt "download b4fdf3f2-a463-4bd5-a2e4-849ac32789d8 T0p&S3cr3t /tmp/bouncy_castle_decrypted.gif"
[info] running pl.datart.csft.client.Download b4fdf3f2-a463-4bd5-a2e4-849ac32789d8 T0p&S3cr3t /tmp/bouncy_castle_decrypted.gif
[2021-06-20 19:32:32,148] [INFO ] [io-compute-1] [pl.datart.csft.client.Download$] [] Download and decrypting your file...
[2021-06-20 19:32:32,672] [INFO ] [io-compute-2] [pl.datart.csft.client.Download$] [] Download succeeded. Your file location is: /tmp/bouncy_castle_decrypted.gif.
[2021-06-20 19:32:32,675] [INFO ] [io-compute-2] [org.http4s.blaze.client.PoolManager] [] Shutting down connection pool: curAllocated=1 idleQueues.size=1 waitQueue.size=0 maxWaitQueueLimit=256 closed=false
```

Here the location of a downloaded and decrypted file is `/tmp/bouncy_castle_decrypted.gif`. 

## Important decisions
### UUID

To identify files UUID is used. Every uploaded file has a new UUID assigned. That UUID is required to download previously uploaded file.

### Password

A password, which is remembered by a user, is used to create a symmetric encryption key. For each file it can be different and in current solution is not explicitly stored anywhere. 

### File storing

Currently, plain file system storing is used.

### SSL

By default, the solution operates on plain HTTP communication, but it's possible to turn on SSL encryption.
One have to provide a **JKS file containing an SSL certificate with a valid certification path**. To do it:

1. Modify client's module `application.conf` to indicate `https://[...]` service.
2. In server's module `application.conf` change:
   - `ssl-enabled = false` to `ssl-enabled = true`
   - `key-store-location = ""` to `key-store-location = "/abs/path/to/file.jks"`
   - `key-store-passphrase = ""` to `key-store-passphrase = "key-store-password"`.

## Things to improve

### UUID - collisions

Using UUID can result in collisions and downloading or overwriting someone's file. Albeit probable, but with a probability so small that it can normally be ignored.

UUID generation in JVM applies to `Version 4 (random)`. To express it in numbers:
 - the number of random version-4 UUIDs which need to be generated in order to have a 50% probability of at least one collision is 2.71 quintillion
 - this number is equivalent to generating 1 billion UUIDs per second for about 85 years. A file containing this many UUIDs, at 16 bytes per UUID, would be about 45 exabytes

Eradicating potential collisions completely can be achieved by introducing users and sessions to a service and storing and fetching files separately per each user.

### File storing

File storing could be changed in many ways to improve durability and availability of data:
 - using DB, for example: https://wiki.postgresql.org/wiki/BinaryFilesInDB
 - using HDFS
 - using Storage Area Network (SAN)
 - using cloud services like Google Cloud Storage or Amazon S3

### Adding other encryption algorithms

Currently, only one is provided. Choosing between a set of them while using client would be nice.

### Networking and streaming

In a solution one can't add, for example, any headers to a streaming request. For such an isolated use case it was omitted. If the module was to be used in other places, adding such a possibility seems to be imminent.